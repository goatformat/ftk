#!/usr/bin/env node

const fs = require('fs')
const path = require('path');
const {execFileSync} = require('child_process');
const os = require('os');

const Threads = require('piscina');
const ProgressBar = require('progress');

const {State, Random} = require('./build');

const STATES = 1e7;
// Technically, storing 1M state strings (length ~68) should only take 650 MiB, but we
// instead see threads using considerably more memory empirically. Allowing threads ~3.2 GiB of
// memory each helps ensure we stay at around 75-85% utilization for the system and don't start
// swapping or crashing.
const MEMORY = 3.436e9;

process.env.PROD = 'true';

if (Threads.isWorkerThread) {
  module.exports = ({seed}) => {
    const state = State.create(new Random(seed));
    const hand = state.hand.slice().sort().join('');
    let result;
    const start = Date.now();
    try {
      const search = state.search(STATES);
      if (search.state) {
        result = ['success', Date.now() - start, hand, search.visited, search.path.length];
      } else {
        result = ['fail', Date.now() - start, hand, search.visited, undefined];
      }
    } catch (e) {
      if (e instanceof RangeError) {
        result = ['exhaust', Date.now() - start, hand, undefined, undefined];
      }
    }
    return result.join(',');
  };
} else {
  const hhmmss = (ms, round = true) => {
    let s = ms / 1000;
    const h = Math.floor(s / 3600);
    const m = Math.floor((s - (h * 3600)) / 60);
    s = s - (h * 3600) - (m * 60);
    if (round) s = Math.round(s);

    const mm = m < 10 ? `0${m}` : `${m}`;
    const ss = s < 10 ? `0${s}` : `${s}`;
    if (h > 0) {
      const hh = h < 10 ? `0${h}` : `${h}`;
      return `${hh}h${mm}m${ss}s`;
    } else {
      return `${mm}m${ss}s`;
    }
  };

  const csv = path.join(__dirname, 'results.csv');
  const old = path.join(__dirname, 'results.old.csv');
  try {
    fs.copyFileSync(csv, old);
  } catch (e) {
    if (e.code !== 'ENOENT') throw e;
  }
  const maxThreads = Math.round(os.totalmem() / MEMORY);
  const threads = new Threads({filename: __filename, maxThreads});

  (async () => {
    const results = [];
    const start = Date.now();
    const n = +process.argv[2] || 1000;

    const progress = new ProgressBar('[:bar] :current/:total (:percent) | :elapsed/:etas', {
      total: n,
      incomplete: ' ',
    });
    const interval = setInterval(() => progress.render(), 1000);

    for (let i = 0; i < n; i++) {
      results.push(threads.run({seed: Random.seed(i)}).then(result => {
        progress.tick();
        return result;
      }));
    }

    await (() => {
      return new Promise(async (resolve, reject) => {
        const output = fs.createWriteStream(csv);
        output.write('result,duration,hand,visited,path\n');
        for (const line of await Promise.all(results)) {
          output.write(line);
          output.write('\n');
        }
        output.on('finish', () => {
          if (fs.existsSync(old)) {
            execFileSync(path.join(__dirname, 'compare'), [old, csv], {stdio: 'inherit'});
          } else {
            execFileSync(path.join(__dirname, 'compare'), [csv], {stdio: 'inherit'});
          }
          resolve(true);
        });
        output.on('error', reject);
        output.close();

        clearInterval(interval);

        console.log(`Finished all ${n} searches in ${hhmmss(Date.now() - start)}`);
      });
    })();
  })();
}
