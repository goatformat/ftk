#!/usr/bin/env node

const fs = require('fs')
const path = require('path');

const Threads = require('piscina');
const ProgressBar = require('progress');
const trakr = require('trakr');

const {State, Random} = require('./build');

process.env.PROD = 'true';

if (Threads.isWorkerThread) {
  module.exports = ({seed}) => {
    const state = State.create(new Random(seed));
    const hand = state.hand.slice().sort().join('');
    let result;
    const start = Date.now();
    try {
      const search = state.search(1e7);
      if (search.state) {
        result = ['success', Date.now() - start, hand, search.visited, search.path.length];
      } else {
        result = ['fail', Date.now() - start, hand, search.visited, undefined];
      }
    } catch (e) {
      if (e instanceof RangeError) {
        result = ['exhaust', Date.now() - start, hand, undefined, undefined];
      }
    }
    return result.join(',');
  };
} else {
  const stats = {
    before: {success: [], fail: [], exhaust: []},
    after: {success: [], fail: [], exhaust: []},
    path: {before: [], after: []},
    diff: {
      success: {success: 0, fail: 0, exhaust: 0},
      fail: {success: 0, fail: 0, exhaust: 0},
      exhaust: {success: 0, fail: 0, exhaust: 0},
    }
  };

  const pct = (a, b) => `${(-(b - a) * 100 / b).toFixed(2)}%`;

  const dec = n => {
    const abs = Math.abs(n);
    if (abs < 1) return n.toFixed(3);
    if (abs < 10) return n.toFixed(2);
    if (abs < 100) return n.toFixed(1);
    return n.toFixed();
  };

  const report = (a, b) => {
    console.log(`count: ${dec(a.cnt)} vs ${dec(b.cnt)} (${pct(a.cnt, b.cnt)})`);
    console.log(`average: ${dec(a.avg)} ± ${dec(a.std)} vs ${dec(b.avg)} ±$ {dec(b.std)} (${pct(a.avg, b.avg)})`);
    console.log(`p50: ${dec(a.p50)} vs ${dec(b.p50)} (${pct(a.p50, b.p50)})`);
    console.log(`p95: ${dec(a.p95)} vs ${dec(b.p95)} (${pct(a.p95, b.p95)})`);
  };

  const hhmmss = (ms, round = true) => {
    let s = ms / 1000;
    const h = Math.floor(s / 3600);
    const m = Math.floor((s - (h * 3600)) / 60);
    s = s - (h * 3600) - (m * 60);
    if (round) s = Math.round(s);

    const mm = m < 10 ? `0${m}` : `${m}`;
    const ss = s < 10 ? `0${s}` : `${s}`;
    if (h > 0) {
      const hh = h < 10 ? `0${h}` : `${h}`;
      return `${hh}h${mm}m${ss}s`;
    } else {
      return `${mm}m${ss}s`;
    }
  };

  const parse = line => {
    const [result, d, hand, visited, p] = line.split(',');
    return {result, duration: +d, hand, visited, path: +p};
  };

  const csv = path.join(__dirname, 'results.csv');
  const input = (() => {
    try {
      const result = [];
      const lines = fs.readFileSync(csv, 'utf8').split('\n');
      for (let i = 1; i < lines.length; i++) {
        if (!lines[i]) continue;
        const a = parse(lines[i]);
        stats.before[a.result].push(a.duration);
        if (a.result === 'success') stats.path.before.push(a.path);
        result.push(a);
      }
      return result;
    } catch (e) {
      console.error(e);
      return undefined;
    }
  })();
  try {
    fs.copyFileSync(csv, path.join(__dirname, 'results.old.csv'));
  } catch (e) {
    if (e.code !== 'ENOENT') throw e;
  }
  const output = fs.createWriteStream(csv);

  const threads = new Threads({filename: __filename, maxThreads: 20}); // DEBUG

  (async () => {
    const results = [];
    const start = Date.now();
    const n = +process.argv[2] || 1000;
    const progress = new ProgressBar('[:bar] :current/:total (:percent) | :elapsed/:etas', {
      total: n,
      incomplete: ' ',
    });
    const interval = setInterval(() => progress.render(), 1000);

    for (let i = 0; i < n; i++) {
      results.push(threads.run({seed: Random.seed(i)}).then(result => {
        progress.tick();
        return result;
      }));
    }

    output.write('result,duration,hand,visited,path\n');
    for (const [i, line] of (await Promise.all(results)).entries()) {
      if (input && input[i]) {
        const a = parse(line);
        const b = input[i];
        stats.after[a.result].push(a.duration);
        if (a.result === 'success') stats.path.after.push(a.path);
        stats.diff[b.result][a.result]++;
      }
      output.write(line);
      output.write('\n');
    }
    clearInterval(interval);
    output.close();

    console.log(`Finished all ${n} searches in ${hhmmss(Date.now() - start)}`);
    if (input) {
      const before = {
        success: trakr.Stats.compute(stats.before.success),
        fail: trakr.Stats.compute(stats.before.fail),
        exhaust: trakr.Stats.compute(stats.before.exhaust),
      };
      const after = {
        success: trakr.Stats.compute(stats.after.success),
        fail: trakr.Stats.compute(stats.after.fail),
        exhaust: trakr.Stats.compute(stats.after.exhaust),
      };
      for (const result of ['success', 'fail', 'exhaust']) {
        const a = after[result];
        const b = before[result];
        if (!(b.cnt || a.cnt)) continue;
        console.log(`\n${result.toUpperCase()}\n---`);
        report(a, b);
        console.log(`${stats.before[result].length} -> success: ${stats.diff[result].success}, fail: ${stats.diff[result].fail}, exhaust: ${stats.diff[result].exhaust}`);
      }
      console.log(`\nPATH\n---`);
      report(trakr.Stats.compute(stats.path.after),trakr.Stats.compute(stats.path.before));
    }
  })();
}
