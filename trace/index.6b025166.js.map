{"mappings":"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","sources":["node_modules/@parcel/runtime-js/lib/runtime-1bbacc809ed10769.js","html/trace/trace.ts","node_modules/@parcel/runtime-js/lib/runtime-702b65b9633992f1.js"],"sourcesContent":["require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"jKx1T\\\":\\\"index.6b025166.js\\\",\\\"9JOvB\\\":\\\"worker.75bb9c50.js\\\",\\\"kpOvT\\\":\\\"index.c9f6f4eb.js\\\"}\"));","import * as workerpool from 'workerpool';\n\nimport {State, Random, Option, ID, DeckID, DATA, OPTIONS} from '../../src';\nimport {createElement, track, renderState} from '../common';\n\nconst CUTOFF = 1e7;\nconst TIMEOUT = {nonprescient: 5 * 1000, total: 60 * 1000};\n// workerpool cancellation seems to not throw CancellationError's on web...\nconst CANCELLED = /Worker(?: is)? terminated/;\n\ntype Success = ['success', number, number, string[], string[]];\ntype Fail = ['fail', number, number];\ntype Exhaust = ['exhaust', number, number];\ntype Result = Success | Fail | Exhaust;\ntype Solution = {visited: number} | {visited: number; path: string[]; trace?: string[] };\n\n// Attempts to solve the encoded state s, preferring solutions in order:\n//\n//    - failure from a prescient search\n//    - successful paths from a non-prescient search acheived before the non-prescient timeout\n//    - the shortest successful prescient path achevied before the non-prescient timeout\n//    - any successful path returned from a search after the non-prescient timeout\n//\n// The solver is also subject to a global total timeout\nconst solve = async (encoded: string): Promise<Solution> => {\n  let done: Result | undefined = undefined;\n\n  const pool = workerpool.pool(new URL('../worker.ts', import.meta.url).pathname);\n\n  // Whether we are allowed to return prescient successful results (ie. whether we've exceeded the\n  // non-prescient timeout)\n  let allowed = false;\n  // The successful searches and all searches - we only return results from the latter in certain\n  // circumstances\n  const successes: Success[] = [];\n  const searches: workerpool.Promise<Result | undefined>[] = [];\n\n  // When we terminate early we need to cancel the pending sibling searches we might have kicked\n  // off. It would seem like pool.terminate(force = true) should do this, but the pool termination\n  // causes crashes instead :(\n  const cleanup = () => { for (const s of searches) if (s.pending) s.cancel().catch(console.error); };\n\n  // If we haven't found a non-prescient success before the non-prescient timeout, return the\n  // shortest prescient success we've seen. Prescient failures would have already caused us to\n  // return from solve at this point, so we can only find success\n  let timeout: ReturnType<typeof setTimeout> | undefined = undefined;\n  const timed = new Promise<void>(resolve => {\n    timeout = setTimeout(() => {\n      for (const result of successes) {\n        if (!done || (done[3] && result[3].length < done[3].length)) done = result;\n      }\n      if (done) {\n        cleanup();\n        pool.terminate().catch(console.error);\n        return resolve();\n      }\n      // We didn't find any results before the non-prescient timeout, open the floodgates up to\n      // return the next success that happens from this point on\n      allowed = true;\n    }, TIMEOUT.nonprescient);\n  });\n\n  try {\n    for (const width of [0.5, 0, 10, 0.25, 5, 0.1, 15]) {\n      for (const prescient of [false, true]) {\n        // No point in scheduling a search if we are already done\n        // TODO: can this even happen?\n        if (done) continue;\n\n        const desc = `${prescient ? 'prescient' : 'non-prescient'} ${width === 0 ? 'best-first' : 'BULB'} search${width ? ` (width=${width})` : ''}`;\n        const search = pool.exec('solve', [encoded, CUTOFF, prescient, width])\n          .timeout(TIMEOUT.total)\n          .then((result: Result) => {\n            // If we are finished already no point in doing anything at this point\n            // TODO: can this even happen?\n            if (done) return;\n\n            if (result[0] === 'success') {\n              console.log(`Found a path of length ${result[3].length} for in ${result[1]}ms after searching ${result[2]} states using ${desc}`);\n              successes.push(result);\n              if (allowed || !prescient) {\n                done = result;\n                cleanup();\n              }\n            } else if (result[0] === 'fail') {\n              console.log(`Searched all ${result[2]} states in ${result[1]}ms with ${desc} and did not find any winning path.`);\n              // NOTE: we can only terminate if prescient because non-prescient might report\n              // failures due to having a smaller search space\n              if (prescient) {\n                done = result;\n                cleanup();\n              }\n            } else {\n              console.log(`Gave up after searching ${CUTOFF} states in ${result[1]}ms with ${desc} due to exhaustion.`);\n            }\n\n            return result;\n          }).catch(err => {\n            if (err instanceof workerpool.Promise.TimeoutError) {\n              console.log(`Timed out after ${TIMEOUT.total}ms of searching using ${desc}.`);\n            } else if (err instanceof workerpool.Promise.CancellationError || CANCELLED.test(err.message)) {\n              console.log(`Cancelled ${desc}.`);\n            } else {\n              console.log(`Crashed which searching using ${desc}`, err);\n            }\n\n            return undefined;\n          });\n        searches.push(search);\n      }\n    }\n\n    // Stop waiting if we get a failed prescient, successful non-prescient, or are past the\n    // non-prescient timeout. If we need to wait for all searches, exit with exhaustion\n    await Promise.race([timed, Promise.all(searches).then(results => {\n      if (done) return done;\n\n      for (const result of results) {\n        // timeout / cancel / crash\n        if (!result) continue;\n\n        if (!done) {\n          done = result;\n        } else if (result[3]) {\n          // TODO: can this even happen? should have set done if exiting with success\n          done = !done[3] ? result : result[3].length < done[3].length ? result : done;\n        } else if (result[2]) {\n          // This should only cover the exhaust case - if we encountered failure we should have\n          // already terminated, otherwise just figure out the result with the most states visited\n          // (should all be CUTOFF)\n          done = !done[2] ? result : result[2] > done[2] ? result : done;\n        }\n      }\n\n      return done;\n    })]);\n\n    // done can still be undefined here if everything was a timeout / cancel / crash\n    return (!done ? {visited: -1} : done[3]\n      ? {visited: done[2], path: done[3], trace: done[4]}\n      : {visited: done[2]});\n  } finally {\n    if (timeout) clearTimeout(timeout);\n    pool.terminate().catch(console.error);\n  }\n};\n\nconst render = (s: State, rendered: HTMLElement, banished: DeckID[] = [], graveyard: ID[] = []) => {\n  rendered.appendChild(renderState(s, banished, graveyard));\n\n  const wrapper = createElement('div', 'wrapper');\n  const details = createElement('details');\n  const summary = createElement('summary');\n\n  let code = createElement('code');\n  let pre = createElement('pre');\n  pre.textContent = s.toString();\n  code.appendChild(pre);\n  summary.appendChild(code);\n  details.appendChild(summary);\n\n  code = createElement('code');\n  pre = createElement('pre');\n  pre.textContent = s.next().map(({key, score}) =>\n    `${State.decode(key).toString()} = ${score.toFixed(2)}`).join('\\n');\n  code.appendChild(pre);\n  details.appendChild(code);\n  wrapper.appendChild(details);\n  rendered.appendChild(wrapper);\n\n  return rendered;\n};\n\nconst win = (path: string[], trace: string[]) => {\n  const banished: DeckID[] = [];\n  const graveyard: ID[] = [];\n\n  const root = createElement('div');\n\n  let div = createElement('div', 'trace');\n  let last = '';\n  let major = 0;\n  let ul = createElement('ul');\n  for (const line of trace) {\n    const minor = line.startsWith('  ');\n    if (!minor) {\n      if (major) {\n        div.appendChild(ul);\n        ul = createElement('ul');\n        root.appendChild(div);\n        div = createElement('div', 'trace');\n      }\n\n      if (path[major - 1]) {\n        const s = State.decode(path[major - 1], true);\n        const activated = last.startsWith('Activate')\n          ? DATA[/\"(.*?)\"/.exec(last)![1]].id\n          : (last.startsWith('Set') && !last.endsWith('face-down'))\n            ? DATA[/then activate(?: face-down)? \"(.*?)\"/.exec(last)![1]].id\n            : undefined;\n        track(s.banished, banished, activated);\n        track(s.graveyard, graveyard, activated);\n\n        const rendered = createElement('div', 'state');\n        root.appendChild(render(s, rendered, banished, graveyard));\n      }\n      last = line;\n      major++;\n\n      const span = createElement('span');\n      span.innerHTML = line.replace(/\"(.*?)\"/g, (_, g: string) => `\"<b>${g}</b>\"`);\n      div.appendChild(span);\n    } else {\n      const li = createElement('li');\n      li.textContent = line;\n      ul.appendChild(li);\n    }\n  }\n  root.appendChild(div);\n\n  return root;\n};\n\nconst lose = (s: State) => {\n  const rendered = createElement('div', 'state');\n\n  const div = createElement('div', 'trace');\n  const span = createElement('span');\n  span.innerHTML = s.trace![0].replace(/\"(.*?)\"/g, (_, g: string) => `\"<b>${g}</b>\"`);\n  div.appendChild(span);\n  rendered.appendChild(div);\n  return render(s, rendered);\n};\n\nconst state = (() => {\n  const arg = (window.location.hash || window.location.search).slice(1);\n  const seed = (n: string) => Random.seed(n && !isNaN(+n) ? +n : ~~(Math.random() * (2 ** 31 - 1)));\n  const fallback = OPTIONS.includes(arg[0] as Option)\n    ? State.create(State.decklist(arg[0] as Option), new Random(seed(arg.slice(1))), true)\n    : State.create(State.decklist('S'), new Random(seed(arg)), true);\n  if (arg) {\n    try {\n      const s = State.decode(decodeURIComponent(arg), true);\n      if (!State.verify(s).length) return s;\n    } catch {\n      return fallback;\n    }\n  }\n  return fallback;\n})();\nconsole.log(`State: ${state.toString()} (${state.encode()})`);\n\nconst content = document.getElementById('content')!;\nwhile (content.firstChild) content.removeChild(content.firstChild);\n\nconst loader = createElement('div', 'loader');\nconst spinner = createElement('div', 'spinner');\nloader.appendChild(spinner);\ncontent.appendChild(loader);\n\n// Promise.resolve(state.search({cutoff: CUTOFF, prescient: false, width: 0.5})).then(result => {\nsolve(state.encode()).then(result => {\n  if (content.firstChild) content.removeChild(content.firstChild);\n\n  if (!('path' in result)) {\n    const div = createElement('div');\n    div.textContent = `Unsuccessfully searched ${result.visited} states.`;\n    content.appendChild(div);\n    content.appendChild(createElement('br'));\n    content.appendChild(lose(state));\n  } else {\n    const div = createElement('div');\n    div.textContent = `Found a path of length ${result.path.length} after searching ${result.visited} states:`;\n    content.appendChild(div);\n    content.appendChild(createElement('br'));\n    content.appendChild(win(result.path, result.trace!));\n  }\n}).catch(console.error);\n","module.exports = require('./helpers/bundle-url').getBundleURL('jKx1T') + \"../\" + require('./helpers/bundle-manifest').resolve(\"9JOvB\");"],"names":["parcelRequire","register","JSON","parse","$4728382ffb959750$var$TIMEOUT","$4728382ffb959750$var$CANCELLED","$3ad68d0db7b67be0$exports","getBundleURL","resolve","$4728382ffb959750$var$render","s","rendered","banished","graveyard","appendChild","$iPHaw","renderState","wrapper","createElement","details","summary","code","pre","textContent","toString","next","map","key","score","$l7khe","State","decode","toFixed","join","$4728382ffb959750$var$state","arg","window","location","hash","search","slice","seed","n","Random","isNaN","Math","random","fallback","OPTIONS","includes","create","decklist","decodeURIComponent","verify","length","console","log","encode","$4728382ffb959750$var$content","document","getElementById","firstChild","removeChild","$4728382ffb959750$var$loader","$4728382ffb959750$var$spinner","async","encoded","done","pool","$ahpAG","URL","pathname","allowed","successes","searches","cleanup","pending","cancel","catch","error","timeout","timed","Promise","setTimeout","result","terminate","width","prescient","desc","exec","then","push","err","TimeoutError","CancellationError","test","message","race","all","results","visited","path","trace","clearTimeout","$4728382ffb959750$var$solve","div","root","last","major","ul","line","startsWith","li","activated","DATA","id","endsWith","undefined","track","span","innerHTML","replace","_","g","$4728382ffb959750$var$win","$4728382ffb959750$var$lose"],"version":3,"file":"index.6b025166.js.map"}