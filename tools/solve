#!/usr/bin/env node
require('source-map-support').install();

const fs = require('fs');
const path = require('path');
const {execFileSync} = require('child_process');

const workerpool = require('workerpool');

const {State, Random} = require('../build');
const {hhmmss, maxWorkers} = require('./utils');

const TIMEOUT = 60 * 60 * 1000;
const CUTOFF = 2e7;

var VERBOSE = !!process.env.VERBOSE;
const log = (...args) => VERBOSE && console.log(...args);

(async () => {
  const seeds = [];
  if (process.argv.length < 3) {
    console.error('Usage: solve <seed|file of seeds>');
    process.exit(1);
  }

  if (isNaN(+process.argv[2])) {
    for (const line of fs.readFileSync(process.argv[2], 'utf8').split('\n')) {
      if (!line) continue;
      seeds.push(+line);
    }
  } else {
    seeds.push(+process.argv[2]);
    VERBOSE = true;
  }

  const pool = workerpool.pool(path.join(__dirname, 'worker.js'), {maxWorkers: maxWorkers(CUTOFF)});

  const start = Date.now();
  const cohorts = {};
  const searches = [];
  for (const seed of seeds) {
    cohorts[seed] = [];
    for (const width of [0.5, 0, 10, 0.25, 5, 0.1, 15]) {
      for (const prescient of [true, false]) {
        if (typeof cohorts[seed][0] === 'string') continue;

        const desc = `${prescient ? 'prescient' : 'non-prescient'} ${width === 0 ? 'best-first' : 'BULB'} search${width ? ` (width=${width})` : ''}`;
        const search = pool.exec('search', [Random.seed(seed), CUTOFF, prescient, width, true]).timeout(TIMEOUT).then(result => {
          if (typeof cohorts[seed][0] === 'string') return;

          if (result[0] === 'success') {
            log(`Found a path of length ${result[4].length} for seed ${seed} in ${hhmmss(result[1])} after searching ${result[3]} states using ${desc}:\n${State.display(result[4], result[5])}`);
            for (const s of cohorts[seed]) if (s.pending && s !== search) s.cancel();
            cohorts[seed] = result;
          } else if (result[0] === 'fail') {
            log(`Searched all ${result[3]} states of seed ${seed} in ${hhmmss(result[1])} with ${desc} and did not find any winning path.`);
            // NOTE: we can only terminate if prescient because non-prescient might report failures due to having a smaller search space
            if (prescient) {
              for (const s of cohorts[seed]) if (s.pending && s !== search) s.cancel();
              cohorts[seed] = result;
            }
          } else {
            log(`Gave up after searching ${CUTOFF} states of seed ${seed} in ${hhmmss(result[1])} with ${desc} due to exhaustion.`);
          }
          return result;
        }).catch(err => {
          if (err instanceof workerpool.Promise.TimeoutError) {
            log(`Timed out after ${hhmmss(TIMEOUT)} of searching seed ${seed} using ${desc}.`);
          } else if (err instanceof workerpool.Promise.CancellationError) {
            log(`Cancelled ${desc} of seed ${seed}.`);
          } else {
            log(`Crashed which searching seed ${seed} using ${desc}`, err);
          }
        });
        if (typeof cohorts[seed][0] !== 'string') cohorts[seed].push(search);
        searches.push(search);
      }
    }
  }

  await Promise.all(searches);
  pool.terminate();

  if (seeds.length > 1) {
    const csv = path.join(__dirname, 'logs', 'solutions.csv');
    const old = path.join(__dirname, 'logs', 'solutions.old.csv');
    try {
      fs.copyFileSync(csv, old);
    } catch (e) {
      if (e.code !== 'ENOENT') throw e;
    }
    const out = (Object.entries(cohorts)).map(
      ([seed, [result, duration, hand, visited, p]]) => [result, duration, hand, visited, p?.length, seed].join(','));
    fs.writeFileSync(csv, `result,duration,hand,visited,path,seed\n${out.join('\n')}`);
    console.log(`Finished all ${seeds.length} searches in ${hhmmss(Date.now() - start)}`);
    execFileSync(path.join(__dirname, 'compare'), [csv], {stdio: 'inherit'});
  }
})();
